File = { SOI ~ ModStmt* ~ UseStmt* ~ Class* ~ EOI }

ModStmt = { "mod" ~ Id ~ ";" }

UseStmt = { "use" ~ PathExpr ~ ("as" ~ Id)? ~ ";" }

Class = { "class" ~ Id ~ "{" ~ (StaticInit | Func | StaticField | NonStaticField)* ~ "}" }

StaticField = { "static" ~ Id ~ ":" ~ Type ~ ";" }
NonStaticField = { "let" ~ Id ~ ":" ~ Type ~ ";" }

StaticInit = { "static" ~ BlockExpr }
Func = { "fn" ~ Id ~ "(" ~ Params? ~ ")" ~ ("->" ~ Type)? ~ BlockExpr }
Params = { (KwLSelf | Id ~ ":" ~ Type) ~ ("," ~ Id ~ ":" ~ Type)* }

Pattern = { Id | TuplePattern }
TuplePattern = { "(" ~ (Pattern ~ ",")* ~ Pattern? ~ ")" }

Type = { 
    BasicType
    | KwUSelf
    | PathExpr
    | TupleType
    | ArrType
}
BasicType = _{ KwBool | KwChar | KwI32 | KwF64 }
TupleType = { "(" ~ Type ~ ("," ~ Type)* ~ ")" }
ArrType = { "[" ~ Type ~ ";" ~ Expr? ~ "]" }

Stmt = { LetStmt | ExprWithoutBlock ~ ";" | ExprWithBlock ~ ";"? }
LetStmt = { "let" ~ Pattern ~ (":" ~ Type)? ~ ("=" ~ Expr)? ~ ";" }
Expr = _{ ExprWithBlock | ExprWithoutBlock }
ExprWithBlock = _{ BlockExpr | LoopExpr | IfExpr }
ExprWithoutBlock = _{
    ContinueExpr
    | BreakExpr
    | ReturnExpr
    | AssignExpr
    | OpExpr
}

LoopExpr = { "loop" ~ BlockExpr }
IfExpr = { "if" ~ Expr ~ BlockExpr ~ ("else" ~ (BlockExpr | IfExpr))? }
BlockExpr = { "{" ~ Stmt* ~ ExprWithoutBlock? ~ "}" }

ContinueExpr = { "continue" }
BreakExpr = { "break" ~ Expr? }
ReturnExpr = { "return" ~ Expr? }

GroupedExpr = { "(" ~ Expr ~ ")" }
PrimaryExpr = { LiteralExpr | KwLSelf | GroupedExpr | ExprWithBlock | Type }
ArgsExpr = { "(" ~ (Expr ~ ",")* ~ Expr? ~ ")" }
ObjAccessExpr = { "." ~ Id }
PathAccessExpr = { "::" ~ Id }
ArrAccessExpr = { "[" ~ Expr ~ "]" }
CallExpr = { PrimaryExpr ~ (ArgsExpr | ObjAccessExpr | PathAccessExpr | ArrAccessExpr)* }
StructExprField = { Id ~ (":" ~ Expr)? }
NewExpr = { "new" ~ Type ~ ("{" ~ (StructExprField ~ ",")* ~ StructExprField? ~ "}")? }
UnaryExpr = { (LogNegOp | AddOp | SubOp)* ~ (NewExpr | CallExpr) }
CastExpr = { UnaryExpr ~ ("as" ~ Type)* }
MulExpr = { CastExpr ~ ((MulOp | DivOp | ModOp) ~ CastExpr)* }
AddExpr = { MulExpr ~ ((AddOp | SubOp) ~ MulExpr)* }
CompExpr = { AddExpr ~ ((LeOp | LtOp | GeOp | GtOp) ~ AddExpr)* }
EqExpr = { CompExpr ~ ((EqOp | NeOp) ~ CompExpr)* }
LogAndExpr = { EqExpr ~ ("&&" ~ EqExpr)* }
LogOrExpr = { LogAndExpr ~ ("||" ~ LogAndExpr)* }
OpExpr = { LogOrExpr }
AssignExpr = { LogOrExpr ~ AssignOp ~ LogOrExpr }

AssignOp = { "=" }
EqOp = { "==" }
NeOp = { "!=" }
GeOp = { ">=" }
GtOp = { ">" }
LeOp = { "<=" }
LtOp = { "<" }
AddOp = { "+" }
SubOp = { "-" }
MulOp = { "*" }
DivOp = { "/" }
ModOp = { "%" }
LogNegOp = { "!" }

LiteralExpr = {
    KwTrue
    | KwFalse
    | KwNull
    | EmptyLiteral
    | IntLiteral
    | FloatLiteral
    | StringLiteral
    | CharLiteral
}

EmptyLiteral = { "(" ~ ")" }
IntLiteral = { ASCII_DIGIT+ }
FloatLiteral = @{ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+ }
StringLiteral = @{ "\"" ~ ("\\" ~ ANY | !"\"" ~ ANY)* ~ "\"" }
CharLiteral = @{ "'" ~ ("\\" ~ ANY | !"'" ~ ANY)* ~ "'" }

PathExpr = ${ (Id | KwCrate | KwSuper) ~ ("::" ~ (Id | KwSuper))* }
Id = @{ !KeyWord ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

KwLSelf = { "self" }
KwUSelf = { "Self" }
KwSuper = { "super" }
KwCrate = { "crate" }
KwBool = { "bool" }
KwChar = { "char" }
KwI32 = { "i32" }
KwF64 = { "f64" }
KwTrue = { "true" }
KwFalse = { "false" }
KwNull = { "null" }
KeyWord = @{ 
    "class" | "struct" | "enum" | "union" | "interface" | "fn" | "let" | "where"
    | "static" | "const" | "mut" | "priv" | "pub" | "virtual" | "override"
    | KwLSelf | KwUSelf | KwSuper | KwCrate | "extern" | "mod" | "use"
    | "as" | "break" | "continue" | "else" | "for" | "if" | "in" | "loop" | "match" | "return" | "while"
    | KwBool | KwChar | KwI32 | KwF64
    | KwFalse | KwTrue | KwNull
    | "yield" | "typeof"
}

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ (!NEWLINE ~ ANY)* }

