use crate::lang::ast::ast::{AST, Type, Op};
use crate::ir::flag::*;

grammar;

pub File: Box<AST> = {
    <classes: Class*> => Box::new(AST::File(classes)),
};

// Class
//  "class" Id "{" Member* "}"
Class: Box<AST> = {
    "class" <id: Id> "{" <m: Member*> "}" => {
        let mut fields = Vec::new();
        let mut methods = Vec::new();
        for mem in m {
            match mem.as_ref() {
                AST::Func(_, _, _, _) => methods.push(mem),
                AST::Field(_, _, _) => fields.push(mem),
                _ => panic!("Parser error"),
            }
        }
        Box::new(AST::Class(id, methods, fields))
    }
};

// Member
//  Func
//  Field
Member: Box<AST> = {
    Func,
    Field
};

// Field
//  "static" Id ":" Type ";"
//  "let" Id ":" Type ";"
Field: Box<AST> = {
    "static" <id: Id> ":" <ty: Type> ";" => {
        let mut flag = Flag::default();
        flag.set(FlagTag::Static);
        Box::new(AST::Field(id, ty, flag))
    },
    "let" <id: Id> ":" <ty: Type> ";" => {
        Box::new(AST::Field(id, ty, Flag::default()))
    },
};

// Func
//  "fn" Id "(" Params? ")" ("->" Type)? BlockExpr
Func: Box<AST> = {
    "fn" <id: Id> "(" <ps: Params?> ")" <ret: ("->" <Type>)?> <b: BlockExpr> => {
        Box::new(AST::Func(id, ret.unwrap_or(Box::new(Type::empty())), ps.unwrap_or(Vec::new()), b))
    }
};

// Params
//  "self" ("," Id ":" Type)*
//  (Id ":" Type ",")* Id ":" Type
Params: Vec<Box<AST>> = {
    "self" <ps: ("," <Id> ":" <Type>)*> => {
        let mut params = vec![Box::new(AST::Param(
            String::from("self"),
            Box::new(Type::Unk),
            Flag::default(),
        ))];
        for (p, t) in ps {
            params.push(Box::new(AST::Param(p, t, Flag::default())))
        }
        params
    },
    <ps: (<Id> ":" <Type> ",")*> <e: (<Id> ":" <Type>)> => {
        let mut ps: Vec<Box<AST>> = ps.into_iter().map(
            |(p, t)| Box::new(AST::Param(p, t, Flag::default()))).collect();
        ps.push(Box::new(AST::Param(e.0, e.1, Flag::default())));
        ps
    },
};

// Pattern
//  IdPattern
//      Id
//  TuplePattern
//      "(" (Pattern ",")* Pattern? ")"
Pattern: Box<AST> = {
    <id: Id> => Box::new(AST::Id(id)),
    "(" <ps: (<Pattern> ",")*> <e: Pattern?> ")" => {
        let mut ps = ps;
        match e {
            Some(e_) => ps.push(e_),
            _ => (),
        };
        unimplemented!("Tuple Pattern is not implemented");
    }
}

// type
//  "bool"
//  "i32"
//  "f64"
//  Id ("::" Id)*
//  "(" Type ("," Type)* ")"
//  "[" Type ";" Expr "]"
Type: Box<Type> = {
    "bool" => Box::new(Type::Bool),
    "i32" => Box::new(Type::I32),
    "f64" => Box::new(Type::F64),
    <v: (<Id> "::")*> <e: Id> => {
        let mut v = v;
        v.push(e);
        Box::new(Type::Class(v))
    },
    "(" <v: (<Type> ",")*> <e: Type> ")" => {
        let mut v = v;
        v.push(e);
        Box::new(Type::Tuple(v))
    },
    "[" <t: Type> ";" Expr "]" => unimplemented!("Array type not implemented"),
};

// Stmt
//  LetStmt: "let" Pattern (":" Type)? ("=" Expr)? ";"
//  ExprWithoutBlock ";"
//  ExprWithBlock ";"?
Stmt: Box<AST> = {
    "let" <p: Pattern> <ty: (":" <Type>)?> <init: ("=" <Expr>)?> ";" => {
        Box::new(AST::Var(p, ty.unwrap_or(Box::new(Type::Unk)), Flag::default(), init.unwrap_or(Box::new(AST::None))))
    },
    <ExprWithoutBlock> ";",
    <ExprWithBlock> ";"?,
};

// Expr
//  ExprWithBlock
//  ExprWithoutBlock
Expr: Box<AST> = {
    ExprWithBlock,
    ExprWithoutBlock,
};

// ExprWithBlock
//  BlockExpr
//  LoopExpr
//      "loop" BlockExpr
//  IfExpr
ExprWithBlock: Box<AST> = {
    BlockExpr,
    "loop" <b: BlockExpr> => Box::new(AST::Loop(b.is_expr(), b)),
    IfExpr,
};

// ExprWithoutBlock
//  ContinueExpr
//  BreakExpr
//  ReturnExpr
//  OpExpr
ExprWithoutBlock: Box<AST> = {
    "continue" => Box::new(AST::Continue),
    "break" <v: Expr?> => Box::new(AST::Break(v.unwrap_or(Box::new(AST::None)))),
    "return" <v: Expr?> => Box::new(AST::Return(v.unwrap_or(Box::new(AST::None)))),
    OpExpr,
};

// ElseExpr
//  BlockExpr
//  IfExpr
ElseExpr: Box<AST> = {
    BlockExpr,
    IfExpr,
};

// IfExpr
//  "if" OpExpr BlockExpr ("else" ElseExpr)?
IfExpr: Box<AST> = {
    "if" <cond: OpExpr> <then: BlockExpr> <els: ("else" <ElseExpr>)?> => {
        Box::new(AST::If(then.is_expr(), cond, then, els.unwrap_or(Box::new(AST::None))))
    }
};

// BlockExpr
//  "{" Stmt* ExprWithoutBlock? "}"
BlockExpr: Box<AST> = {
    "{" <s: Stmt*> <e: ExprWithoutBlock?> "}" => {
        let mut s = s;
        match e {
            Some(e_) => s.push(e_),
            _ => (),
        }
        Box::new(AST::Block(if s.len() == 0 { true } else { s.last().unwrap().is_expr() }, s))
    },
};

// OpExpr
//  NegOpExpr
//      "-" OpExpr
//      "!" OpExpr
//  ArithAndLogBinaryExpr
//  ComparisonExpr
//  BoolExpr
//  CastExpr
//  AssignExpr
OpExpr: Box<AST> = {
    #[precedence(level="1")]
    Id => Box::new(AST::Id(<>)),
    #[precedence(level="1")]
    "self" => Box::new(AST::Id(String::from("self"))),
    #[precedence(level="1")]
    LiteralExpr,

    #[precedence(level="2")]
    #[assoc(side="left")]
    <o1: OpExpr> "::" <o2: OpExpr> => Box::new(AST::Binary(Op::StaticAccess, o1, o2)),
    
    #[precedence(level="3")]
    "(" <OpExpr> ")",
    #[precedence(level="3")]
    <f: OpExpr> "(" <args: (<Expr> ",")*> <arg: Expr?> ")" => {
        let mut args = args;
        if let Some(arg_) = arg {
            args.push(arg_);
        }
        Box::new(AST::Call(f, args))
    },
    #[precedence(level="3")]
    #[assoc(side="left")]
    <o1: OpExpr> "." <o2: OpExpr> => Box::new(AST::Binary(Op::ObjAccess, o1, o2)),
    #[precedence(level="3")]
    <o1: OpExpr> "[" <o2: OpExpr> "]" => Box::new(AST::Binary(Op::ArrayAccess, o1, o2)),
    #[precedence(level="3")]
    #[assoc(side="right")]
    "new" <ty: Type> => Box::new(AST::New(ty)),

    #[precedence(level="4")]
    #[assoc(side="right")]
    "-" <o: OpExpr> => Box::new(AST::Unary(Op::Neg, o)),
    #[precedence(level="4")]
    #[assoc(side="right")]
    "!" <o: OpExpr> => Box::new(AST::Unary(Op::LogNot, o)),

    #[precedence(level="5")]
    #[assoc(side="left")]
    <val: OpExpr> "as" <ty: Type> => Box::new(AST::Cast(ty, val)),

    #[precedence(level="6")]
    #[assoc(side="left")]
    <o1: OpExpr> "*" <o2: OpExpr> => Box::new(AST::Binary(Op::Mul, o1, o2)),
    #[precedence(level="6")]
    #[assoc(side="left")]
    <o1: OpExpr> "/" <o2: OpExpr> => Box::new(AST::Binary(Op::Div, o1, o2)),
    #[precedence(level="6")]
    #[assoc(side="left")]
    <o1: OpExpr> "%" <o2: OpExpr> => Box::new(AST::Binary(Op::Mod, o1, o2)),

    #[precedence(level="7")]
    #[assoc(side="left")]
    <o1: OpExpr> "+" <o2: OpExpr> => Box::new(AST::Binary(Op::Add, o1, o2)),
    #[precedence(level="7")]
    #[assoc(side="left")]
    <o1: OpExpr> "-" <o2: OpExpr> => Box::new(AST::Binary(Op::Sub, o1, o2)),

    #[precedence(level="8")]
    #[assoc(side="left")]
    <o1: OpExpr> ">" <o2: OpExpr> => Box::new(AST::Binary(Op::Gt, o1, o2)),
    #[precedence(level="8")]
    #[assoc(side="left")]
    <o1: OpExpr> ">=" <o2: OpExpr> => Box::new(AST::Binary(Op::Ge, o1, o2)),
    #[precedence(level="8")]
    #[assoc(side="left")]
    <o1: OpExpr> "<" <o2: OpExpr> => Box::new(AST::Binary(Op::Lt, o1, o2)),
    #[precedence(level="8")]
    #[assoc(side="left")]
    <o1: OpExpr> "<=" <o2: OpExpr> => Box::new(AST::Binary(Op::Le, o1, o2)),

    #[precedence(level="9")]
    #[assoc(side="left")]
    <o1: OpExpr> "==" <o2: OpExpr> => Box::new(AST::Binary(Op::Eq, o1, o2)),
    #[precedence(level="9")]
    #[assoc(side="left")]
    <o1: OpExpr> "!=" <o2: OpExpr> => Box::new(AST::Binary(Op::Ne, o1, o2)),

    #[precedence(level="10")]
    #[assoc(side="left")]
    <o1: OpExpr> "&&" <o2: OpExpr> => Box::new(AST::Binary(Op::LogAnd, o1, o2)),

    #[precedence(level="11")]
    #[assoc(side="left")]
    <o1: OpExpr> "||" <o2: OpExpr> => Box::new(AST::Binary(Op::LogOr, o1, o2)),

    #[precedence(level="12")]
    #[assoc(side="right")]
    <o1: OpExpr> "=" <o2: OpExpr> => Box::new(AST::Binary(Op::Assign, o1, o2)),
};

// LiteralExpr
LiteralExpr: Box<AST> = {
    "true" => Box::new(AST::Bool(true)),
    "false" => Box::new(AST::Bool(false)),
    "null" => Box::new(AST::Null),
    "(" ")" => unimplemented!("() is not implemented"),
    r"\d+" => Box::new(AST::Int(<>.parse::<i32>().expect("literal parse to i32 failed"))),
    r"\d+\.\d+" => Box::new(AST::Float(<>.parse::<f64>().expect("literal parse to f64 failed"))),
    r#""[^\\"]*(\\.[^\\"]*)*""# => {
        let mut chars = <>.chars();
        chars.next(); // skip first '"'
        let mut s = String::new();
        loop {
            match chars.next() {
                Some(ch) => {
                    match ch {
                        '\\' => {
                            // escape
                            match chars.next() {
                                Some(ch) => match ch {
                                    'n' => s.push('\n'),
                                    _ => unimplemented!("Unsupported escape char"),
                                },
                                None => panic!("Invalid string literal"),
                            }
                        }
                        '"' => break,
                        _ => s.push(ch),
                    }
                }
                None => unreachable!(),
            }
        }
        Box::new(AST::String(s))
    },
    r"'[^\\']*(\\.[^\\']*)*'" => {
        let mut chars = <>.chars();
        chars.next(); // skip first '\''
        let ch = Box::new(AST::Char(match chars.next().unwrap() {
            '\'' => panic!("Empty char literal"),
            '\\' => chars.next().unwrap().into(),
            c => c.into(),
        }));
        match chars.next() {
            Some('\'') => (),
            Some(_) => panic!("Too many chars in char literal"),
            None => panic!("Invalid char literal"),
        }
        ch
    },
}

Id: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
};
